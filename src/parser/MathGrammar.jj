/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */

 options{  static = true;}PARSER_BEGIN(MathGrammar)package parser;

import calculator.MathExpression;
import calculator.BinaryExpression;
import calculator.UnaryExpression;
import calculator.BinaryOperator;
import calculator.UnaryOperator;
import calculator.Number;
public class MathGrammar{  public static void main(String args []) throws ParseException  {    MathGrammar parser = new MathGrammar(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an expression like \"1+(2+3)*4\" :");      MathExpression expr = MathGrammar.one_line();      System.out.println("Result is:\n" + expr.evaluate());    }  }}PARSER_END(MathGrammar)SKIP :{  " "| "\r"| "\t"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < LOG : "log" >}TOKEN :{  < CONSTANT : (< DIGIT >)+ ("." < DIGIT >)? >| < #DIGIT : [ "0"-"9" ] >| < EXP_END : "\n" >}MathExpression one_line() :{}{  sum() < EXP_END >  {    return sum();  }| ";"  {    return null;  }}MathExpression sum() :{  MathExpression expr1, expr2;}{  expr1 = term()  (    < PLUS >     expr2 = term()    {      return new BinaryExpression(expr1, expr2, BinaryOperator.ADDITION);    }  | < MINUS >     expr2 = term()    {      return new BinaryExpression(expr1, expr2, BinaryOperator.SUBSTRACTION);    }  )*}MathExpression term() :{  MathExpression expr1, expr2;}{  expr1 = unary()  (    < MULTIPLY >     expr2 = unary()    {      return new BinaryExpression(expr1, expr2, BinaryOperator.MULTIPLICATION);    }  | < DIVIDE >     expr2 = unary()    {      return new BinaryExpression(expr1, expr2, BinaryOperator.DIVISION);    }  )*}MathExpression unary() :{}{  < MINUS > element()  {    return new UnaryExpression(element(), UnaryOperator.MINUS);  }| < LOG > element()  {    return new UnaryExpression(element(), UnaryOperator.LOG);  }| element()  {    return element();  }}MathExpression element() :{  Token t;}{  t = < CONSTANT >  {    return new Number(Float.parseFloat(t.image));  }| "(" sum() ")"  {    return sum();  }}